<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Part 2</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
  <div class="tocheadb">
    <h1 class="tochead" id="heading_id_2"><a id="pgfId-1079531"></a><a id="pgfId-1099956"></a><a id="id_vkac9x82ali"></a>Part 2. Calculus and physical simulation</h1>
  </div>

  <p class="body"><a id="pgfId-1099957"></a><span class="fm-part-initial-cap">I</span>n part 2 of this book, we embark on an overview of calculus<a id="marker-1109403"></a>. Broadly speaking, calculus is the study of continuous change, so we talk a lot about how to measure rates of change of different quantities and what these rates of change can tell us.</p>

  <p class="body"><a id="pgfId-1107741"></a>In my opinion, calculus gets a bad rap as a difficult subject because of how much algebra is required, not because the concepts are unfamiliar. If you’ve ever owned or driven a car, you have an intuitive understanding of rates and cumulative values: a speedometer measures your <i class="fm-italics">rate</i> of movement over time, while an odometer measures the <i class="fm-italics">cumulative</i> miles driven. To some extent their measurements must agree. If your speedometer reads a higher value over a period of time, your odometer should increase by a larger amount, and vice versa.</p>

  <p class="body"><a id="pgfId-1099959"></a>In calculus, we learn that if we have a function giving a cumulative value at any time, we can calculate its rate of change, also as a function of time. This operation of taking a “cumulative” function and returning a “rate” function is called a <i class="fm-italics">derivative</i>. Similarly, if we start with a rate function, we can reconstruct a cumulative function that agrees with it, which is an operation called an <i class="fm-italics">integral</i>. We spend all of chapter 8 making sure these conversions make conceptual sense, applying it to measured fluid volume (a cumulative function) and fluid flow rate (a corresponding rate function). In chapter 9, we extend these ideas to multiple dimensions. To simulate a moving object in a video game engine, we need to consider the relationship between speed and position in each coordinate independently.</p>

  <p class="body"><a id="pgfId-1099960"></a>Once you get a conceptual understanding of calculus in chapters 8 and 9, we’ll cover the mechanics in chapter 10. We’ll have more fun with this than in an ordinary calculus class, because Python will do most of the formula crunching for us. We model mathematical expressions like little computer programs, which we can parse and transform to find their derivatives and integrals. Chapter 10, therefore, shows quite a different approach to doing math in code, and this approach is called <i class="fm-italics">symbolic programming</i>.</p>

  <p class="body"><a id="pgfId-1099961"></a>In chapter 11, we return to calculus in multiple dimensions. While speed on a speedometer or fluid flow rate through a pipe are functions that vary over time, we can also have functions that vary over space. These functions take vectors as inputs and return numbers or vectors as outputs. For instance, representing the strength of gravity as a function over a 2D space allows us to add some interesting physics to our video game from chapter 7. A key calculus operation for functions that vary over space is the <i class="fm-italics">gradient</i>, an operation that tells us the spatial direction that a function increases at the highest rate. Because it measures a rate, a gradient is like a vector version of an ordinary derivative. In chapter 12, we use the gradient to <i class="fm-italics">optimize</i> a function or to find the input for which it returns the largest output. By following the direction of the gradient vector, we can find increasingly large outputs, and eventually, we can converge on a maximum value for the whole function.</p>

  <p class="body"><a id="pgfId-1099962"></a>In chapter 13, we cover a completely different application of calculus. It turns out that the integral of a function tells us a lot about the geometry of the graph of a function. In particular, integrating the product of two functions tells us about how similar their graphs are. We’ll apply this kind of analysis to sound waves. A <i class="fm-italics">sound wave</i> is a graph of a function describing a sound, and the graph tells us whether the sound is loud or soft, high or low pitched, and so on. Comparing a sound wave with different musical notes, we can find out the musical notes it contains. Thinking of a sound wave as a function corresponds to an important mathematical concept called a <i class="fm-italics">Fourier series</i>.</p>

  <p class="body"><a id="pgfId-1099963"></a>As compared to part 1, part 2 is more of a smorgasbord of topics, but there are two main themes you should keep your eye on. The first is the concept of the rate of change of a function; whether a function is increasing or decreasing at a point tells us how to find bigger or smaller values. The second is the idea of an operation that takes functions as inputs and returns functions as outputs. In calculus, the answer to many questions comes in the form of a function. These two ideas will be key to our machine learning applications in part 3.</p>
</body>
</html>
